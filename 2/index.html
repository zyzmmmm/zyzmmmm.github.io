<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 100px;
        }
        p {
            font-size: 18px;
        }
        .image-container {
            display: flex;
            justify-content: center;
            gap: 20px; 
        }
        .image-item {
            text-align: center;
        }
        .image-item img {
            max-width: 400px; 
            height: auto;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">CS 180 Programming Project 2: Fun with Filters and Frequencies!</h1>
    <h2 style="text-align: center;">Zhang Yuze</h2>
    
    <h2>Part 1</h2>
    <h3>Part 1.1: Finite Difference Operator</h3>
    <p>In this task, I use Finite Difference Operator to convolve the image, calculate the gradient size 
        of each pixel, and finally use a threshold to determine whether a pixel is an edge. If the threshold 
        is large, not all edges can be represented; If the threshold is small, unwanted things may appear. 
        After my adjustments, the output image is as follows:</p>

    <div class="image-container">
        <div class="image-item">
            <img src="./resources/raw_church.jpg" alt="Image 1">
            <p>church.tif</p>
        </div>
    </div>

    <hr>
    
    <h3>Part 1.2: Derivative of Gaussian (DoG) Filter</h3>

    <p>I used cv2.getGaussianKernel() to obtain a 1D Gaussian kernel and then calculated the outer product of 
        this kernel with its transpose to get a 2D Gaussian kernel. First, I convolved the image with this kernel 
        to produce a blurred image. Then, I applied the Finite Difference Operator mentioned in the previous 
        question to detect edges, followed by thresholding for binarization. If I use the same threshold as in 
        the previous question, not all edges can be detected because the image was blurred; however, when I lowered 
        the threshold, the edge detection improved, and the resulting image became clearer and more continuous.</p>

    <div class="image-container">
        <div class="image-item">
            <img src="./media/cathedral.jpg" alt="Image 1">
            <p>(5, 2)(12, 3)</p>
        </div>
        <div class="image-item">
            <img src="./media/church.jpg" alt="Image 2">
            <p>(25, 4)(58, -4)</p>
        </div>
        <div class="image-item">
            <img src="./media/emir.jpg" alt="Image 3">
            <p>(49, 24)(107, 40)</p>
        </div>
    </div>

    <p>Due to the associative property of convolution, convolving the 2D Gaussian kernel with the Finite Difference 
        Operator first and then applying the resulting convolution kernel to the image will produce the same result.</p>

    <div class="image-container">
        <div class="image-item">
            <img src="./resources/NCC function.jpg" alt="Image 1">
            <p>NCC</p>
        </div>
    </div>
    
    <hr>
    
    <h2>Part 2: Fun with Frequencies!</h2>
    <h3>Part 2.1: Image "Sharpening"</h3>
    <p>图像有RGB三个通道，对于单通道图像，使用上面创造的高斯滤波器，再拼接起来，我得到了低频率的模糊图像。再使用impulse filter减去Gaussian filterUsing，得到高频率的边缘图像。为了锐化原始图像，我们只需要在原始图像中加入高频率图像，将原图像的边缘细节变清晰。此外，我们还可以将1比例的原始图像与n比例的高频图像结合，通过调节n的大小，可以得到不同程度锐化的图像(n=0的时候为原图)。</p>

    <div class="image-container">
        <div class="image-item">
            <img src="./resources/NCC function.jpg" alt="Image 1">
            <p>NCC</p>
        </div>
    </div>
    
    <p>实际上，我们还可以将impulse filter minus the Gaussian filter这一过程使用一个filter表示，如下图。将锐化图像模糊后再进行锐化</p>
    
    <div class="image-container">
        <div class="image-item">
            <img src="./resources/Image_pyramid.svg" alt="Image 1">
            <p>https://en.wikipedia.org/wiki/Pyramid_(image_processing)</p>
        </div>
    </div>

    <hr>
    
    <h3>Part 2.2: Hybrid Images</h3>
    <h4>Overview</h4>
        
    <p>实现Hybrid Images的原理是通过一个图像的低频与另一个图像的高频结合，产生的图像在近距和远距下观看得到不同的结果。使用高斯滤波器提取人像的低频特征，使用Part 2.1的方法提取猫图像的高频特征，将两张图像取平均值，就能得到两者的Hybrid Image。我们还可以像Part 2.2一样调整两者的比例，决定人和猫的特征哪个更明显。当然，在这之前必须将两张图像对齐并放缩到相同大小，才能得到比较好的效果。和Part 2.2一样，对每个通道进行相同的操作，并在最后合并起来。</p>

    <h4>Other Images</h4>
    
    <hr>
    
    <h2 style="text-align: center;">Multi-resolution Blending and the Oraple journey</h2>
    <h3>Part 2.3: Gaussian and Laplacian Stacks</h3>
    <h4>Overview</h4>

    <p>高斯栈指用高斯滤波器对图像反复卷积，获得一组越来越模糊的图像；而拉普拉斯栈可以从高斯栈相邻图像做差得到，最后一层与高斯栈的最后一层相同。对苹果和orange图像应用高斯栈和拉普拉斯栈，在最后一层得到十分模糊的图像，在拉普拉斯栈的中间部分，我得到了图像由细节到粗略的边缘特征。将边缘特征归一化后，使用脉冲函数将两者结合，得到以下输出。</p>

    <h4>Other Images</h4>
    
     <div class="image-container">
        <div class="image-item">
            <img src="./resources/emir before edge detect.jpg" alt="Image 1">
            <p>before</p>
        </div>
        <div class="image-item">
            <img src="./media/emir.jpg" alt="Image 2">
            <p>after</p>
        </div>
    </div>
    <hr>

    <h3>Part 2.4: Multiresolution Blending</h3>

    <h4>Overview</h4>

    <p>首先，我尝试将两图像左右混合起来，将拉普拉斯栈作用在两图像上，并使用一个垂直边界的01mask，创造它的高斯栈，与图像的层数相同。每一层将两图像使用mask中的系数加权相加，得到每一层的混合图像。将每一层的图像相加，得到最后的混合图像。</p>

    <p>如果想以其他的方式混合图像，只需要更改mask的形式，例如：</p>
    
    <h4>Other Images</h4>

     <div class="image-container">
        <div class="image-item">
            <img src="./media/cathedral.jpg" alt="Image 1">
            <p>(5, 2)(12, 3)</p>
        </div>
        <div class="image-item">
            <img src="./media/church.jpg" alt="Image 2">
            <p>(25, 4)(58, -4)</p>
        </div>
        <div class="image-item">
            <img src="./media/emir.jpg" alt="Image 3">
            <p>(49, 24)(107, 40)</p>
        </div>
    </div>

     <div class="image-container">
        <div class="image-item">
            <img src="./media/harvesters.jpg" alt="Image 1">
            <p>(60, 17)(124, 14)</p>
        </div>
        <div class="image-item">
            <img src="./media/icon.jpg" alt="Image 2">
            <p>(42, 17)(90, 23)</p>
        </div>
        <div class="image-item">
            <img src="./media/lady.jpg" alt="Image 3">
            <p>(56, 9)(120, 13)</p>
        </div>
    </div>
    
     <div class="image-container">
        <div class="image-item">
            <img src="./media/melons.jpg" alt="Image 1">
            <p>(80, 10)(177, 13)</p>
        </div>
        <div class="image-item">
            <img src="./media/monastery.jpg" alt="Image 2">
            <p>(-3, 2)(3, 2)</p>
        </div>
        <div class="image-item">
            <img src="./media/onion_church.jpg" alt="Image 3">
            <p>(52, 25)(107, 35)</p>
        </div>
    </div>

    <div class="image-container">
        <div class="image-item">
            <img src="./media/sculpture.jpg" alt="Image 1">
            <p>(33, -11)(140, -26)</p>
        </div>
        <div class="image-item">
            <img src="./media/self_portrait.jpg" alt="Image 2">
            <p>(78, 29)(176, 37)</p>
        </div>
        <div class="image-item">
            <img src="./media/three_generations.jpg" alt="Image 3">
            <p>(54, 12)(111, 9)</p>
        </div>
    </div>

    <div class="image-container">
        <div class="image-item">
            <img src="./media/tobolsk.jpg" alt="Image 1">
            <p>(3, 3)(6, 3)</p>
        </div>
        <div class="image-item">
            <img src="./media/train.jpg" alt="Image 2">
            <p>(41, 2)(85, 29)</p>
        </div>
    </div>
    
    
</body>
</html>
